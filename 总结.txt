单页面应用
  什么叫单页面应用：可以理解为一个web应用，和普通的web应用不同的是，首次只需加载页面中所需要的静态资源，其余的数据通过ajax调用Rest Api接口获取
  优点：首次加载所耗的资源少，可以有效的节省带宽和服务器资源
  缺点：不利于SEO

模块化管理
  模块概念：将业务逻辑按照功能划分为一个个的结构体，这种结构体就称之为模块，每个模块之间保持独立性，有利于代码的可维护性和单元测试
  模块语法：
    模块定义：
      define(function () {}) -- 匿名模块
      define()               -- 具名模块，加入模块被移动到其他模块下，还需要改名，require会根据当前js文件的路径生成moduleId(不带有后缀名的模块相对路径)，在require的时候，根据baseUrl + moduleId的形式
    模块导出：
      模块结构体返回值
    模块引用:
      按需引用(考虑到的是循环依赖)和异步加载
      require 步骤
      1、得到当前使用require语法的模块文件的路径，并且创建属性为id: xx, state: 0, deps: [], factory: function() {}, exports
      2、
  功能：
    模块定义（解决模块命名冲突）
    处理依赖（按需引用）如果在a模块中依赖了b模块，当a模块加载完成后，a模块的的factory不能执行，需要加载b模块，如果b模块还有依赖，那么必须等b模块和b模块的依赖全部加载完成，才能执行a模块的factory
    模块加载（异步加载）根据moduleId创建script，设置async属性
    require方法其实就是得到当前模块的url，构造一个对象包括moduleId、state、deps、factory、exports等属性，开始加载其依赖项
    开始加载第一个依赖模块a时候，当a下载完成之后，开始执行a模块的define方法，执行完成后，将该模块push到待执行队列中，如果有依赖，然后在加载a模块的依赖
    如果b模块中有对a模块的循环依赖，则不对a模块进行加载，调用b模块的factory，此时a模块一定在未执行factory队列中，可以设置为undefined
    这样就能保证在待执行factory队列中永远是依赖的模块在前
    如果此时依赖模块b没有依赖项，则调用当前模块的factory()，将结果赋予缓存对象当前模块对象的exports的值
