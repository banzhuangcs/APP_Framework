单页面应用
  什么叫单页面应用：可以理解为一个web应用，和普通的web应用不同的是，首次只需加载页面中所需要的静态资源，其余的数据通过ajax调用Rest Api接口获取
  优点：首次加载所耗的资源少，可以有效的节省带宽和服务器资源
  缺点：不利于SEO

模块化管理
  模块概念：将业务逻辑按照功能划分为一个个的结构体，这种结构体就称之为模块，每个模块之间保持独立性，有利于代码的可维护性和单元测试
  模块语法：
    模块定义：
      define(function () {}) -- 匿名模块
      define()               -- 具名模块，加入模块被移动到其他模块下，还需要改名，require会根据当前js文件的路径生成moduleId(不带有后缀名的模块相对路径)，在require的时候，根据baseUrl + moduleId的形式
    模块导出：
      模块结构体返回值
    模块引用:
      按需引用(考虑到的是循环依赖)和异步加载
      require 步骤
      1、得到当前使用require语法的模块文件的路径，并且创建属性为id: xx, state: 0, deps: [], factory: function() {}, exports
      2、
  功能：
    模块定义（解决模块命名冲突）
    处理依赖（按需引用）如果在a模块中依赖了b模块，当a模块加载完成后，a模块的的factory不能执行，需要加载b模块，如果b模块还有依赖，那么必须等b模块和b模块的依赖全部加载完成，才能执行a模块的factory
    模块加载（异步加载）根据moduleId创建script，设置async属性
    require方法其实就是得到当前模块的url，构造一个对象包括moduleId、state、deps、factory、exports等属性，开始加载其依赖项
    开始加载第一个依赖模块a时候，当a下载完成之后，开始执行a模块的define方法，执行完成后，将该模块push到待执行队列中，如果有依赖，然后在加载a模块的依赖
    如果b模块中有对a模块的循环依赖，则不对a模块进行加载，调用b模块的factory，此时a模块一定在未执行factory队列中，可以设置为undefined
    这样就能保证在待执行factory队列中永远是依赖的模块在前
    如果此时依赖模块b没有依赖项，则调用当前模块的factory()，将结果赋予缓存对象当前模块对象的exports的值


  for in 遍历对象的时候，对象和对象原型对象都会遍历，configurable(是否可删除)、embleable(是否可遍历)，对象属性和原型对象属性相同的不会遍历出来

  当使用函数进行隐式转换时，首先会调用自身的toString，如果自定义了toString()方法那么就使用自定义的返回结果，valueOf()优先级更高

  柯里化：部分求值，把接收多个参数的函数变换成每次接收部分参数的函数，新函数接收余下的参数并返回结果，最经典的常用方式是_bind
  
  函数式编程：
    1、函数是一等公民，可以当做参数传递也可以返回
    2、只使用表达式，不用语句表达式是一个单纯的运算过程，总有返回值，语句是执行某种操作，没有返回值，函数式编程的硬性要求只使用表达式，不使用语句，每一步都有返回值
    3、纯函数，函数上下文和其他上下文之间没有引用和修改的操作，而且每次都返回新值
    4、闭包：在不在当前上下文执行的内部方法，并且该内部方法有权方位当前上下文的变量
    5、科里化：将传入多个参数的函数转换成每次传入部分参数的函数，剩余参数传给返回的